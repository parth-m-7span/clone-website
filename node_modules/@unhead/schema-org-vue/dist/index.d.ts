import { ComponentResolver } from 'unplugin-vue-components';
import { MaybeComputedRefOrPromise } from '@unhead/vue';
import * as vue from 'vue';

interface SchemaOrgResolverOptions {
    /**
     * prefix for headless ui components used in templates
     *
     * @default ""
     */
    prefix?: string;
}
declare const schemaAutoImports: string[];
declare const schemaOrgAutoImports: {
    from: string;
    imports: string[];
}[];
declare const schemaOrgComponents: string[];
declare function SchemaOrgResolver(options?: SchemaOrgResolverOptions): ComponentResolver;

type ItemAvailability = 'BackOrder' | 'Discontinued' | 'InStock' | 'InStoreOnly' | 'LimitedAvailability' | 'OnlineOnly' | 'OutOfStock' | 'PreOrder' | 'PreSale' | 'SoldOut';
interface OfferSimple extends Thing {
    '@type'?: 'Offer';
    /**
     * A schema.org URL representing a schema itemAvailability value (e.g., https://schema.org/OutOfStock).
     */
    availability?: OptionalSchemaOrgPrefix<ItemAvailability>;
    /**
     * The price, omitting any currency symbols, and using '.' to indicate a decimal place.
     */
    price: number | string;
    /**
     * The currency used to describe the product price, in three-letter ISO 4217 format.
     */
    priceCurrency?: string;
    /**
     * @todo A PriceSpecification object, including a valueAddedTaxIncluded property (of either true or false).
     */
    priceSpecification?: unknown;
    /**
     * The date after which the price is no longer available.
     */
    priceValidUntil?: ResolvableDate;
    url?: string;
}
interface Offer extends OfferSimple {
}

interface AggregateOfferSimple extends Thing {
    /**
     * The lowest price of the group, omitting any currency symbols, and using '.' to indicate a decimal place.
     */
    lowPrice: number | string;
    /**
     *  The highest price of the group, omitting any currency symbols, and using '.' to indicate a decimal place.
     */
    highPrice: number | string;
    /**
     * The currency used to describe the product price, in a three-letter ISO 4217 format.
     */
    priceCurrency?: string;
    /**
     * The number of offers in the group
     */
    offerCount?: number | string;
    /**
     * An array of Offer pieces, referenced by ID.
     */
    offers?: NodeRelations<Offer>;
}
interface AggregateOffer extends AggregateOfferSimple {
}

interface AggregateRatingSimple extends Thing {
    '@type'?: 'AggregateRating';
    /**
     * The total number of ratings for the item on your site. At least one of ratingCount or reviewCount is required.
     */
    ratingCount?: number | string;
    /**
     * Specifies the number of people who provided a review with or without an accompanying rating. At least one of ratingCount or reviewCount is required.
     */
    reviewCount?: number | string;
    /**
     * A numerical quality rating for the item, either a number, fraction, or percentage
     * (for example, "4", "60%", or "6 / 10").
     * Google understands the scale for fractions and percentages,
     * since the scale is implied in the fraction itself or the percentage.
     * The default scale for numbers is a 5-point scale, where 1 is the lowest value and 5 is the highest value.
     * If another scale is intended, use bestRating and worstRating.
     */
    ratingValue: number | string;
    /**
     * The highest value allowed in this rating system. If bestRating is omitted, 5 is assumed.
     */
    bestRating?: number | string;
    /**
     * The lowest value allowed in this rating system. If worstRating is omitted, 1 is assumed.
     */
    worstRating?: number | string;
}
interface AggregateRating extends AggregateRatingSimple {
}

interface ImageSimple extends Thing {
    /**
     * The URL of the image file (e.g., /images/cat.jpg).
     */
    url: string;
    /**
     * The fully-qualified, absolute URL of the image file (e.g., https://www.example.com/images/cat.jpg).
     * Note: The contentUrl and url properties are intentionally duplicated.
     */
    contentUrl?: string;
    /**
     * A text string describing the image.
     * - Fall back to the image alt attribute if no specific caption field exists or is defined.
     */
    caption?: string;
    /**
     * The height of the image in pixels.
     * - Must be used with width.
     */
    height?: number;
    /**
     * The width of the image in pixels.
     * - Must be used with height.
     */
    width?: number;
    /**
     * The language code for the textual content; e.g., en-GB.
     * - Only needed when providing a caption.
     */
    inLanguage?: string;
}
interface ImageObject extends ImageSimple {
}

interface VideoSimple extends Thing {
    /**
     * The title of the video.
     */
    name?: string;
    /**
     * A description of the video (falling back to the caption, then to 'No description').
     */
    description?: string;
    /**
     * A reference-by-ID to an imageObject.
     */
    thumbnailUrl?: NodeRelation<ImageObject>;
    /**
     * The date the video was published, in ISO 8601 format (e.g., 2020-01-20).
     */
    uploadDate?: ResolvableDate;
    /**
     * Whether the video should be considered 'family friendly'
     */
    isFamilyFriendly?: boolean;
    /**
     * The URL of the image file (e.g., /images/cat.jpg).
     */
    url: string;
    /**
     * The fully-qualified, absolute URL of the image file (e.g., https://www.example.com/images/cat.jpg).
     * Note: The contentUrl and url properties are intentionally duplicated.
     */
    contentUrl?: string;
    /**
     * A text string describing the image.
     * - Fall back to the image alt attribute if no specific caption field exists or is defined.
     */
    caption?: string;
    /**
     * The height of the image in pixels.
     * - Must be used with width.
     */
    height?: number;
    /**
     * The width of the image in pixels.
     * - Must be used with height.
     */
    width?: number;
    /**
     * The language code for the textual content; e.g., en-GB.
     * - Only needed when providing a caption.
     */
    inLanguage?: string;
    /**
     * The duration of the video in ISO 8601 format.
     */
    duration?: string;
    /**
     * A URL pointing to a player for the video.
     */
    embedUrl?: string;
}
interface VideoObject extends VideoSimple {
}

type ValidArticleSubTypes = 'Article' | 'BlogPosting' | 'AdvertiserContentArticle' | 'NewsArticle' | 'Report' | 'SatiricalArticle' | 'ScholarlyArticle' | 'SocialMediaPosting' | 'TechArticle';
interface ArticleSimple extends Thing {
    ['@type']?: Arrayable$1<ValidArticleSubTypes>;
    /**
     * The headline of the article (falling back to the title of the WebPage).
     * Headlines should not exceed 110 characters.
     */
    headline?: string;
    /**
     * A summary of the article (falling back to the page's meta description content).
     */
    description?: string;
    /**
     * A reference-by-ID to the WebPage node.
     */
    isPartOf?: IdReference;
    /**
     * The time at which the article was originally published, in ISO 8601 format; e.g., 2015-10-31T16:10:29+00:00.
     */
    datePublished?: ResolvableDate;
    /**
     * The time at which the article was last modified, in ISO 8601 format; e.g., 2015-10-31T16:10:29+00:00.
     */
    dateModified?: ResolvableDate;
    /**
     * A reference-by-ID to the author of the article.
     */
    author?: NodeRelations<Identity>;
    /**
     * A reference-by-ID to the publisher of the article.
     */
    publisher?: NodeRelations<Identity>;
    /**
     * An array of all videos in the article content, referenced by ID.
     */
    video?: NodeRelations<VideoObject>;
    /**
     * An image object or referenced by ID.
     * - Must be at least 696 pixels wide.
     * - Must be of the following formats+file extensions: .jpg, .png, .gif ,or .webp.
     *
     * Must have markup of it somewhere on the page.
     */
    image?: NodeRelations<ImageObject | string>;
    /**
     * An array of references by ID to comment pieces.
     */
    comment?: NodeRelations<Comment>;
    /**
     * A thumbnail image relevant to the Article.
     */
    thumbnailUrl?: string;
    /**
     * An integer value of the number of comments associated with the article.
     */
    commentCount?: number;
    /**
     * An integer value of the number of words in the article.
     */
    wordCount?: number;
    /**
     * An array of keywords which the article has (e.g., ["cats","dogs","cake"]).
     */
    keywords?: string[];
    /**
     * An array of category names which the article belongs to (e.g., ["cats","dogs","cake"]).
     */
    articleSection?: string[];
    /**
     * The language code for the article; e.g., en-GB.
     */
    inLanguage?: string;
    /**
     * A SpeakableSpecification object which identifies any content elements suitable for spoken results.
     */
    speakable?: unknown;
    /**
     * The year from which the article holds copyright status.
     */
    copyrightYear?: string;
    /**
     * A reference-by-ID to the Organization or Person who holds the copyright.
     */
    copyrightHolder?: NodeRelations<Identity>;
}
interface Article extends ArticleSimple {
}

type SearchTarget = string | `${string}{search_term_string}${string | undefined}`;
interface SearchAction {
    '@type'?: 'SearchAction';
    /**
     * An object of type EntryPoint, with a relative URL which describes the URL pattern of the internal search function
     * (e.g., /search?query={search_term_string}).
     */
    target: SearchTarget | {
        '@type'?: 'EntryPoint';
        'urlTemplate'?: SearchTarget;
    };
    /**
     * The search term string as described in the target (e.g., search_term_string).
     */
    'query-input'?: {
        '@type'?: 'PropertyValueSpecification';
        'valueRequired'?: boolean;
        'valueName'?: 'search_term_string';
    };
}

/**
 * A WebSite is a set of related web pages and other items typically served from a single web domain and accessible via URLs.
 */
interface WebSiteSimple extends Thing {
    /**
     * The site's home URL (excluding a trailing slash).
     */
    url?: string;
    /**
     * The name of the website.
     */
    name: string;
    /**
     * A description of the website (e.g., the site's tagline).
     */
    description?: string;
    /**
     * A reference-by-ID to the Organization which publishes the WebSite
     * (or an array of Organization and Person in the case that the website represents an individual).
     */
    publisher?: NodeRelations<Identity>;
    /**
     * A SearchAction object describing the site's internal search.
     */
    potentialAction?: Arrayable$1<(SearchAction | unknown)>;
    /**
     * The language code for the WebSite; e.g., en-GB.
     * If the website is available in multiple languages, then output an array of inLanguage values.
     */
    inLanguage?: Arrayable$1<string>;
}
interface WebSite extends WebSiteSimple {
}

interface PostalAddressSimple extends Thing {
    /**
     * The building number and street (e.g., 123 fake road ).
     */
    streetAddress: string;
    /**
     * The postal code.
     */
    postalCode: string;
    /**
     * The two-digit country-code representing the country (e.g., US ).
     */
    addressCountry: string;
    /**
     * The town, city or equivalent.
     */
    addressLocality?: string;
    /**
     * The region or district.
     */
    addressRegion?: string;
    /**
     * A PO box number.
     */
    postOfficeBoxNumber?: string;
}
interface PostalAddress extends PostalAddressSimple {
}

/**
 * An organization such as a school, NGO, corporation, club, etc.
 */
interface OrganizationSimple extends Thing {
    /**
     * A reference-by-ID to an image of the organization's logo.
     *
     * - The image must be 112x112px, at a minimum.
     * - Make sure the image looks how you intend it to look on a purely white background
     * (for example, if the logo is mostly white or gray,
     * it may not look how you want it to look when displayed on a white background).
     */
    logo?: NodeRelation<ImageObject | string>;
    /**
     * The site's home URL.
     */
    url?: string;
    /**
     * The name of the Organization.
     */
    name: string;
    /**
     * An array of URLs representing declared social/authoritative profiles of the organization
     * (e.g., a Wikipedia page, or Facebook profile).
     */
    sameAs?: Arrayable$1<string>;
    /**
     * An array of images which represent the organization (including the logo ), referenced by ID.
     */
    image?: NodeRelations<ImageObject | string>;
    /**
     * A reference-by-ID to an PostalAddress piece.
     */
    address?: NodeRelations<PostalAddress>;
}
interface Organization extends OrganizationSimple {
}

/**
 * A list item, e.g. a step in a checklist or how-to description.
 */
interface ListItemSimple extends Thing {
    '@type'?: 'ListItem';
    /**
     *  The name of the page in question, as it appears in the breadcrumb navigation.
     */
    name?: string;
    /**
     * The unmodified canonical URL of the page in question.
     * - If a relative path is provided, it will be resolved to absolute.
     * - Item is not required for the last entry
     */
    item?: string | Thing;
    /**
     *  An integer (starting at 1), counting the 'depth' of the page from (including) the homepage.
     */
    position?: number;
}
interface ListItem extends ListItemSimple {
}

interface ItemListSimple extends Thing {
    /**
     * Resolved item list
     */
    itemListElement: NodeRelations<ListItem>;
    /**
     * Type of ordering (e.g. Ascending, Descending, Unordered).
     *
     * @default undefined
     */
    itemListOrder?: 'Ascending' | 'Descending' | 'Unordered';
    /**
     * The number of items in an ItemList.
     * Note that some descriptions might not fully describe all items in a list (e.g., multi-page pagination);
     * in such cases, the numberOfItems would be for the entire list.
     *
     * @default undefined
     */
    numberOfItems?: number;
}
interface ItemList extends ItemListSimple {
}

/**
 * A BreadcrumbList is an ItemList consisting of a chain of linked Web pages,
 * typically described using at least their URL and their name, and typically ending with the current page.
 */
interface BreadcrumbSimple extends ItemList {
    '@type'?: 'BreadcrumbList';
}
interface BreadcrumbList extends BreadcrumbSimple {
}

/**
 * A person (alive, dead, undead, or fictional).
 */
interface PersonSimple extends Thing {
    /**
     * The full name of the Person.
     */
    name: string;
    /**
     * The user bio, truncated to 250 characters.
     */
    description?: string;
    /**
     * An array of URLs representing declared social/authoritative profiles of the person
     * (e.g., a Wikipedia page, or Facebook profile).
     */
    sameAs?: Arrayable$1<string>;
    /**
     * An array of images which represent the person, referenced by ID.
     */
    image?: NodeRelations<ImageObject | string>;
    /**
     * The URL of the users' profile page (if they're affiliated with the site in question),
     * or to their personal homepage/website.
     */
    url?: string;
}
interface Person extends PersonSimple {
}
interface ReadAction {
    '@type'?: 'ReadAction';
    /**
     * An object of type EntryPoint, with a relative URL which describes the URL pattern of the internal search function
     * (e.g., /search?query={search_term_string}).
     */
    target: string[];
}

type ValidSubTypes = 'WebPage' | 'AboutPage' | 'CheckoutPage' | 'CollectionPage' | 'ContactPage' | 'FAQPage' | 'ItemPage' | 'MedicalWebPage' | 'ProfilePage' | 'QAPage' | 'RealEstateListing' | 'SearchResultsPage';
/**
 * A web page.
 * Every web page is implicitly assumed to be declared to be of type WebPage,
 * so the various properties about that webpage, such as breadcrumb may be used.
 */
interface WebPageSimple extends Thing {
    ['@type']?: Arrayable$1<ValidSubTypes>;
    /**
     * The unmodified canonical URL of the page.
     */
    url?: string;
    /**
     * The title of the page.
     */
    name?: string;
    /**
     * The page's meta description content.
     */
    description?: string;
    /**
     * A reference-by-ID to the WebSite node.
     */
    isPartOf?: NodeRelation<WebSite>;
    /**
     * A reference-by-ID to the Organisation node.
     * Note: Only for the home page.
     */
    about?: NodeRelation<Organization>;
    /**
     * A reference-by-ID to the author of the web page.
     */
    author?: NodeRelation<Person | string>;
    /**
     * The language code for the page; e.g., en-GB.
     */
    inLanguage?: Arrayable$1<string>;
    /**
     * The time at which the page was originally published, in ISO 8601 format; e.g., 2015-10-31T16:10:29+00:00.
     */
    datePublished?: ResolvableDate;
    /**
     * The time at which the page was last modified, in ISO 8601 format; e.g., 2015-10-31T16:10:29+00:00.
     */
    dateModified?: ResolvableDate;
    /**
     * A reference-by-ID to a node representing the page's featured image.
     */
    primaryImageOfPage?: NodeRelation<ImageObject | string>;
    /**
     * A reference-by-ID to a node representing the page's breadrumb structure.
     */
    breadcrumb?: NodeRelation<BreadcrumbList>;
    /**
     * An array of all videos in the page content, referenced by ID.
     */
    video?: NodeRelations<VideoObject>;
    /**
     * A SpeakableSpecification object which identifies any content elements suitable for spoken results.
     */
    speakable?: unknown;
    /**
     * Potential actions for this web page.
     *
     * Note it's on by default for most page types.
     */
    potentialAction?: Arrayable$1<(ReadAction | unknown)>;
}
interface WebPage extends WebPageSimple {
}

interface BookSimple extends Thing {
    /**
     * The title of the book.
     */
    name: string;
    /**
     * A description of the course. Display limit of 60 characters.
     */
    description?: string;
    /**
     *  A reference to an Organization piece, representing brand associated with the Product.
     */
    author?: NodeRelation<Identity>;
    /**
     * The URL on your website where the book is introduced or described.
     */
    url?: string;
    /**
     * The URL of a reference page that identifies the work. For example, a Wikipedia, Wikidata, VIAF, or Library of Congress page for the book.
     */
    sameAs?: Arrayable$1<string>;
    /**
     * The edition(s) of the work.
     */
    workExample: NodeRelations<BookEdition>;
}
interface Book extends BookSimple {
}
type BookFormat = OptionalSchemaOrgPrefix<'AudiobookFormat'> | OptionalSchemaOrgPrefix<'EBook'> | OptionalSchemaOrgPrefix<'Hardcover'> | OptionalSchemaOrgPrefix<'Paperback'>;
interface BookEditionSimple extends Thing {
    /**
     * The title of the edition. Only use this when the title of the edition is different from the title of the work.
     */
    name?: string;
    /**
     * The format of the edition.
     */
    bookFormat: BookFormat;
    /**
     * The main language of the content in the edition. Use one of the two-letter codes from the list of ISO 639-1 alpha-2 codes.
     */
    inLanguage?: string;
    /**
     * The ISBN-13 of the edition. If you have ISBN-10, convert it into ISBN-13.
     */
    isbn: string;
    /**
     * The action to be triggered for users to purchase or download the book.
     */
    potentialAction?: Arrayable$1<ReadAction | any>;
    /**
     * The author(s) of the edition.
     */
    author?: NodeRelations<Identity>;
    /**
     * The edition information of the book. For example, 2nd Edition.
     */
    bookEdition?: string;
    /**
     * The date of publication of the edition in YYYY-MM-DD or YYYY format. This can be either a specific date or only a specific year.
     */
    datePublished?: ResolvableDate;
    /**
     * The external or other ID that unambiguously identifies this edition. Multiple identifiers are allowed. For more details, refer to PropertyValue (identifier).
     */
    identifier?: unknown;
    /**
     * The URL of a reference web page that unambiguously indicates the edition. For example, a Wikipedia page for this specific edition. Don't reuse the sameAs of the Work.
     */
    sameAs?: Arrayable$1<string>;
    /**
     * The URL on your website where the edition is introduced or described. It can be the same as workExample.target.urlTemplate.
     */
    url?: string;
}
interface BookEdition extends BookEditionSimple {
}

interface CommentSimple extends Thing {
    /**
     * The textual content of the comment, stripping HTML tags.
     */
    text: string;
    /**
     *  A reference by ID to the parent Article (or WebPage, when no Article is present).
     */
    about?: IdReference;
    /**
     * A reference by ID to the Person who wrote the comment.
     */
    author: NodeRelation<Person>;
}
interface Comment$1 extends CommentSimple {
}

/**
 * Any offered product or service.
 * For example: a pair of shoes; a concert ticket; the rental of a car;
 * a haircut; or an episode of a TV show streamed online.
 */
interface CourseSimple extends Thing {
    /**
     * The title of the course.
     */
    name: string;
    /**
     * A description of the course. Display limit of 60 characters.
     */
    description?: string;
    /**
     *  A reference to an Organization piece, representing brand associated with the Product.
     */
    provider?: NodeRelation<Organization>;
}
interface Course extends CourseSimple {
}

interface PlaceSimple extends Thing {
    '@type'?: 'Place';
    name: string;
    address: NodeRelation<PostalAddress | string>;
    latitude?: number | string;
    longitude?: number | string;
}
interface Place extends PlaceSimple {
}

interface VirtualLocationSimple extends Thing {
    '@type'?: 'VirtualLocation';
    url: string;
}
interface VirtualLocation extends VirtualLocationSimple {
}

type EventAttendanceModeTypes = 'OfflineEventAttendanceMode' | 'OnlineEventAttendanceMode' | 'MixedEventAttendanceMode';
type EventStatusTypes = 'EventCancelled' | 'EventMovedOnline' | 'EventPostponed' | 'EventRescheduled' | 'EventScheduled';
interface EventSimple extends Thing {
    /**
     * Description of the event.
     * Describe all details of the event to make it easier for users to understand and attend the event.
     */
    description?: string;
    /**
     * The end date and time of the item (in ISO 8601 date format).
     */
    endDate?: ResolvableDate;
    /**
     * The eventAttendanceMode of an event indicates whether it occurs online, offline, or a mix.
     */
    eventAttendanceMode?: OptionalSchemaOrgPrefix<EventAttendanceModeTypes>;
    /**
     * An eventStatus of an event represents its status; particularly useful when an event is cancelled or rescheduled.
     */
    eventStatus?: OptionalSchemaOrgPrefix<EventStatusTypes>;
    /**
     * Repeated ImageObject or URL
     *
     * URL of an image or logo for the event or tour.
     * Including an image helps users understand and engage with your event.
     * We recommend that images are 1920px wide (the minimum width is 720px).
     */
    image?: NodeRelations<ImageObject | string>;
    /**
     * The location of the event.
     * There are different requirements depending on if the event is happening online or at a physical location
     */
    location?: NodeRelations<Place | VirtualLocation | string>;
    /**
     * An offer to provide this item—for example, an offer to sell a product,
     * rent the DVD of a movie, perform a service, or give away tickets to an event.
     * Use businessFunction to indicate the kind of transaction offered, i.e. sell, lease, etc.
     * This property can also be used to describe a Demand.
     * While this property is listed as expected on a number of common types, it can be used in others.
     * In that case, using a second type, such as Product or a subtype of Product, can clarify the nature of the offer.
     */
    offers?: NodeRelations<Offer | string>;
    /**
     * An organizer of an Event.
     */
    organizer?: NodeRelation<Identity>;
    /**
     * A performer at the event—for example, a presenter, musician, musical group or actor.
     */
    performer?: NodeRelation<Person>;
    /**
     * Used in conjunction with eventStatus for rescheduled or cancelled events.
     * This property contains the previously scheduled start date.
     * For rescheduled events, the startDate property should be used for the newly scheduled start date.
     * In the (rare) case of an event that has been postponed and rescheduled multiple times, this field may be repeated.
     */
    previousStartDate?: ResolvableDate;
    /**
     * The start date and time of the item (in ISO 8601 date format).
     */
    startDate?: ResolvableDate;
}
interface Event extends EventSimple {
}

interface HowToDirection extends Thing {
    /**
     * The text of the direction or tip.
     */
    text: string;
}

interface HowToStepSimple extends Thing {
    /**
     * A link to a fragment identifier (an 'ID anchor') of the individual step
     * (e.g., https://www.example.com/example-page/#recipe-step-5).
     */
    url?: string;
    /**
     * The instruction string
     * ("e.g., "Bake at 200*C for 40 minutes, or until golden-brown, stirring periodically throughout").
     */
    text: string;
    /**
     * The word or short phrase summarizing the step (for example, "Attach wires to post" or "Dig").
     * Don't use non-descriptive text (for example, "Step 1: [text]") or other form of step number (for example, "1. [text]").
     */
    name?: string;
    /**
     * An image representing the step, referenced by ID.
     */
    image?: NodeRelations<ImageObject | string>;
    /**
     * A video for this step or a clip of the video.
     */
    video?: NodeRelations<VideoObject | string>;
    /**
     * A list of detailed substeps, including directions or tips.
     */
    itemListElement?: NodeRelations<HowToDirection | string>[];
}
interface HowToStep extends HowToStepSimple {
}

/**
 * Instructions that explain how to achieve a result by performing a sequence of steps.
 */
interface HowToSimple extends Thing {
    /**
     * A string describing the guide.
     */
    name: string;
    /**
     * An array of howToStep objects
     */
    step: NodeRelations<HowToStep | string>[];
    /**
     * The total time required to perform all instructions or directions (including time to prepare the supplies),
     * in ISO 8601 duration format.
     */
    totalTime?: string;
    /**
     * Introduction or description content relating to the HowTo guide.
     */
    description?: string;
    /**
     * The language code for the guide; e.g., en-GB.
     */
    inLanguage?: string;
    /**
     * The estimated cost of the supplies consumed when performing instructions.
     */
    estimatedCost?: string | unknown;
    /**
     * Image of the completed how-to.
     */
    image?: NodeRelations<ImageObject | string>;
    /**
     * A supply consumed when performing instructions or a direction.
     */
    supply?: string | unknown;
    /**
     * An object used (but not consumed) when performing instructions or a direction.
     */
    tool?: string | unknown;
    /**
     * A video of the how-to. Follow the list of required and recommended Video properties.
     * Mark steps of the video with hasPart.
     */
    video?: NodeRelations<VideoObject | string>;
}
interface HowTo extends HowToSimple {
}

interface MonetaryAmountSimple extends Thing {
    /**
     * The currency in which the monetary amount is expressed.
     */
    currency: string;
    /**
     * The value of the quantitative value or property value node.
     */
    value: QuantitativeValue;
}
interface MonetaryAmount extends MonetaryAmountSimple {
}
interface QuantitativeSimple extends Thing {
    value?: number;
    minValue?: number;
    maxValue?: number;
    unitText: 'HOUR' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR';
}
interface QuantitativeValue extends QuantitativeSimple {
}

interface JobPostingSimple extends Thing {
    /**
     * The original date that employer posted the job in ISO 8601 format.
     * For example, "2017-01-24" or "2017-01-24T19:33:17+00:00".
     */
    datePosted: ResolvableDate;
    /**
     * The full description of the job in HTML format.
     *
     * The description must be a complete representation of the job, including job responsibilities, qualifications,
     * skills, working hours, education requirements, and experience requirements. The description can't be the same as
     * the title
     */
    description: string;
    /**
     * The organization offering the job position. This must be the name of the company (for example, "Starbucks, Inc"),
     * and not the specific location that is hiring (for example, "Starbucks on Main Street").
     */
    hiringOrganization: NodeRelation<Organization>;
    /**
     * The physical location(s) of the business where the employee will report to work (such as an office or worksite),
     * not the location where the job was posted. Include as many properties as possible. The more properties you provide,
     * the higher quality the job posting is to our users. Note that you must include the addressCountry property.
     */
    jobLocation: NodeRelation<Place>;
    /**
     * The title of the job (not the title of the posting). For example, "Software Engineer" or "Barista"
     */
    title: string;
    /**
     * The actual base salary for the job, as provided by the employer (not an estimate).
     */
    baseSalary?: MonetaryAmount;
    /**
     * Type of employment
     */
    employmentType?: EmploymentType | EmploymentType[];
    /**
     * The date when the job posting will expire in ISO 8601 format. For example, "2017-02-24"
     * or "2017-02-24T19:33:17+00:00".
     */
    validThrough?: ResolvableDate;
    /**
     * A description of the job location (e.g. TELECOMMUTE for telecommute jobs).
     */
    jobLocationType?: 'TELECOMMUTE';
    /**
     * Indicates whether the URL that's associated with this job posting enables direct application for the job.
     */
    directApply?: boolean;
}
interface JobPosting extends JobPostingSimple {
}
type EmploymentType = 'FULL_TIME' | 'PART_TIME' | 'CONTRACTOR' | 'TEMPORARY' | 'INTERN' | 'VOLUNTEER' | 'PER_DIEM' | 'OTHER';

type DayOfWeek = 'Friday' | 'Monday' | 'PublicHolidays' | 'Saturday' | 'Sunday' | 'Thursday' | 'Tuesday' | 'Wednesday';
type Time = `${number}${number}:${number}${number}`;
interface OpeningHoursSimple extends Thing {
    '@type'?: 'OpeningHoursSpecification';
    /**
     * The day of the week for which these opening hours are valid.
     */
    dayOfWeek: Arrayable$1<DayOfWeek>;
    /**
     * The opening hour of the place or service on the given day(s) of the week.
     */
    opens?: Time;
    /**
     * The closing hour of the place or service on the given day(s) of the week.
     */
    closes?: Time;
    /**
     * The date when the item becomes valid.
     */
    validFrom?: ResolvableDate;
    /**
     * The date after when the item is not valid. For example, the end of an offer, salary period, or a period of opening hours.
     */
    validThrough?: ResolvableDate;
}
interface OpeningHoursSpecification extends OpeningHoursSimple {
}

type ValidLocalBusinessSubTypes = 'AnimalShelter' | 'ArchiveOrganization' | 'AutomotiveBusiness' | 'ChildCare' | 'Dentist' | 'DryCleaningOrLaundry' | 'EmergencyService' | 'EmploymentAgency' | 'EntertainmentBusiness' | 'FinancialService' | 'FoodEstablishment' | 'GovernmentOffice' | 'HealthAndBeautyBusiness' | 'HomeAndConstructionBusiness' | 'InternetCafe' | 'LegalService' | 'Library' | 'LodgingBusiness' | 'MedicalBusiness' | 'ProfessionalService' | 'RadioStation' | 'RealEstateAgent' | 'RecyclingCenter' | 'SelfStorage' | 'ShoppingCenter' | 'SportsActivityLocation' | 'Store' | 'TelevisionStation' | 'TouristInformationCenter' | 'TravelAgency';
interface LocalBusinessSimple extends Organization {
    '@type'?: ['Organization', 'LocalBusiness'] | ['Organization', 'LocalBusiness', ValidLocalBusinessSubTypes] | ValidLocalBusinessSubTypes;
    /**
     * The primary public telephone number of the business.
     */
    telephone?: string;
    /**
     * The primary public email address of the business.
     */
    email?: string;
    /**
     * The primary public fax number of the business.
     */
    faxNumber?: string;
    /**
     * The price range of the business, represented by a string of dollar symbols (e.g., $, $$, or $$$ ).
     */
    priceRange?: string;
    /**
     * An array of GeoShape, Place or string definitions.
     */
    areaServed?: unknown;
    /**
     * A GeoCoordinates object.
     */
    geo?: unknown;
    /**
     * The VAT ID of the business.
     */
    vatID?: string;
    /**
     * The tax ID of the business.
     */
    taxID?: string;
    /**
     * The currency accepted.
     */
    currenciesAccepted?: string;
    /**
     * The operating hours of the business.
     */
    openingHoursSpecification?: NodeRelations<OpeningHoursSpecification>;
}
interface LocalBusiness extends LocalBusinessSimple {
}

interface RatingSimple extends Thing {
    '@type'?: 'Rating';
    /**
     * A numerical quality rating for the item, either a number, fraction, or percentage
     * (for example, "4", "60%", or "6 / 10").
     * Google understands the scale for fractions and percentages,
     * since the scale is implied in the fraction itself or the percentage.
     * The default scale for numbers is a 5-point scale, where 1 is the lowest value and 5 is the highest value.
     * If another scale is intended, use bestRating and worstRating.
     */
    ratingValue: number | string;
    /**
     * The highest value allowed in this rating system. If bestRating is omitted, 5 is assumed.
     */
    bestRating?: number;
    /**
     * The lowest value allowed in this rating system. If worstRating is omitted, 1 is assumed.
     */
    worstRating?: number;
}
interface Rating extends RatingSimple {
}

interface ReviewSimple extends Thing {
    /**
     * A title for the review.
     */
    name?: string;
    /**
     * The author of the review.
     */
    author: NodeRelation<Person | string>;
    /**
     * An answer object, with a text property which contains the answer to the question.
     */
    reviewRating: NodeRelation<Rating | number>;
    /**
     * The language code for the question; e.g., en-GB.
     */
    inLanguage?: string;
    /**
     * The date that the review was published, in ISO 8601 date format.
     */
    datePublished?: ResolvableDate;
    /**
     * The text content of the review.
     */
    reviewBody?: string;
}
interface Review extends ReviewSimple {
}

interface MovieSimple extends Thing {
    /**
     * An image that represents the movie.
     */
    image: NodeRelations<string | ImageObject>;
    /**
     * The name of the movie.
     */
    name: string;
    /**
     * Annotation for the average review score assigned to the movie.
     */
    aggregateRating?: NodeRelation<AggregateRating>;
    /**
     * The date the movie was released.
     */
    dateCreated?: ResolvableDate;
    /**
     * The director of the movie.
     */
    director?: NodeRelations<Person | string>;
    /**
     * The director of the movie.
     */
    actor?: NodeRelations<Person | string>;
    /**
     * A nested Review of the movie.
     */
    review?: NodeRelations<Review>;
    /**
     * The trailer of a movie or TV/radio series, season, episode, etc.
     */
    trailer?: NodeRelations<string | VideoObject>;
}
interface Movie extends MovieSimple {
}

/**
 * Any offered product or service.
 * For example: a pair of shoes; a concert ticket; the rental of a car;
 * a haircut; or an episode of a TV show streamed online.
 */
interface ProductSimple extends Thing {
    /**
     * The name of the product.
     */
    name: string;
    /**
     * A reference-by-ID to one or more imageObject's which represent the product.
     * - Must be at least 696 pixels wide.
     * - Must be of the following formats+file extensions: .jpg, .png, .gif ,or .webp.
     */
    image: NodeRelations<ImageObject | string>;
    /**
     *  An array of references-by-ID to one or more Offer or aggregateOffer pieces.
     */
    offers?: NodeRelations<Offer | number>;
    /**
     *  A reference to an Organization piece, representing brand associated with the Product.
     */
    brand?: NodeRelation<Organization>;
    /**
     * A reference to an Organization piece which represents the WebSite.
     */
    seller?: NodeRelation<Organization>;
    /**
     * A text description of the product.
     */
    description?: string;
    /**
     * An array of references-by-id to one or more Review pieces.
     */
    review?: NodeRelations<Review>;
    /**
     * A merchant-specific identifier for the Product.
     */
    sku?: string;
    /**
     * An AggregateRating object.
     */
    aggregateRating?: NodeRelation<AggregateRating>;
    /**
     * An AggregateOffer object.
     */
    aggregateOffer?: NodeRelation<AggregateOffer>;
    /**
     * A reference to an Organization piece, representing the brand which produces the Product.
     */
    manufacturer?: NodeRelation<Organization>;
}
interface Product extends ProductSimple {
}

/**
 * An answer offered to a question; perhaps correct, perhaps opinionated or wrong.
 */
interface AnswerSimple extends Thing {
    text: string;
}
interface Answer extends AnswerSimple {
}

/**
 * A specific question - e.g. from a user seeking answers online, or collected in a Frequently Asked Questions (FAQ) document.
 */
interface QuestionSimple extends Thing {
    /**
     * The text content of the question.
     */
    name: string;
    /**
     * An answer object, with a text property which contains the answer to the question.
     */
    acceptedAnswer: NodeRelation<Answer | string>;
    /**
     * The language code for the question; e.g., en-GB.
     */
    inLanguage?: string;
    /**
     * Alias for `name`
     */
    question?: string;
    /**
     * Alias for `acceptedAnswer`
     */
    answer?: string;
}
interface Question extends QuestionSimple {
}

interface RecipeSimple extends Thing {
    /**
     * A string describing the recipe.
     */
    name?: string;
    /**
     * An image representing the completed recipe, referenced by ID.
     */
    image?: NodeRelation<ImageObject | string>;
    /**
     * An array of strings representing each ingredient and quantity (e.g., "3 apples").
     */
    recipeIngredient: string[];
    /**
     * An array of HowToStep objects.
     */
    recipeInstructions: NodeRelations<HowToStep | string>;
    /**
     * A string describing the recipe.
     */
    description?: string;
    /**
     * The cooking time in ISO 8601 format.
     */
    cookTime?: string;
    /**
     * The time required to prepare the recipe.
     */
    prepTime?: string;
    /**
     * A NutritionInformation node, with a calories property which defines a calorie count as a string (e.g., "270 calories").
     */
    nutrition?: NutritionInformation;
    /**
     * The number of servings the recipe creates (not the number of individual items, if these are different), as a string
     * (e.g., "6", rather than 6).
     */
    recipeYield?: string;
    /**
     * An array of strings representing the tools required in the recipe.
     */
    tools?: string[];
    /**
     * An array of keywords describing the recipe.
     */
    keywords?: string[];
    /**
     * A string describing the cuisine type (e.g., "American" or "Spanish").
     */
    recipeCuisine?: string;
    /**
     * The category of the recipe.
     */
    recipeCategory?: 'Appetizer' | 'Breakfast' | 'Brunch' | 'Dessert' | 'Dinner' | 'Drink' | 'Lunch' | 'Main course' | 'Sauce' | 'Side dish' | 'Snack' | 'Starter';
    /**
     * A RestrictedDiet node, with a value (or array of values
     */
    suitableForDiet?: Partial<'DiabeticDiet' | 'GlutenFreeDiet' | 'HalalDiet' | 'HinduDiet' | 'KosherDiet' | 'LowCalorieDiet' | 'LowFatDiet' | 'LowLactoseDiet' | 'LowSaltDiet' | 'VeganDiet' | 'VegetarianDiet'>[];
    /**
     *  A reference to a video representing the recipe instructions, by ID.
     */
    video?: NodeRelations<VideoObject | IdReference>;
    /**
     * The language code for the guide; e.g., en-GB.
     */
    inLanguage?: string;
    /**
     * A reference-by-ID to the author of the article.
     */
    author?: NodeRelation<Person>;
    /**
     * The date when the recipe was added, in ISO 8601 format.
     */
    datePublished?: ResolvableDate;
}
interface Recipe extends RecipeSimple {
}
interface NutritionInformation extends Thing {
    '@type': 'NutritionInformation';
    /**
     * A calorie count as a string (e.g., "270 calories").
     */
    calories: string;
}

type ApplicationCategory = 'GameApplication' | 'SocialNetworkingApplication' | 'TravelApplication' | 'ShoppingApplication' | 'SportsApplication' | 'LifestyleApplication' | 'BusinessApplication' | 'DesignApplication' | 'DeveloperApplication' | 'DriverApplication' | 'EducationalApplication' | 'HealthApplication' | 'FinanceApplication' | 'SecurityApplication' | 'BrowserApplication' | 'CommunicationApplication' | 'DesktopEnhancementApplication' | 'EntertainmentApplication' | 'MultimediaApplication' | 'HomeApplication' | 'UtilitiesApplication' | 'ReferenceApplication';
interface SoftwareAppSimple extends Thing {
    '@type'?: Arrayable$1<'SoftwareApplication' | 'MobileApplication' | 'VideoGame' | 'WebApplication'>;
    /**
     * The name of the app.
     */
    name?: string;
    /**
     * An offer to sell the app.
     * For developers, offers can indicate the marketplaces that carry the application.
     * For marketplaces, use offers to indicate the price of the app for a specific app instance.
     */
    offers: NodeRelations<Offer>;
    /**
     * The average review score of the app.
     */
    aggregateRating?: NodeRelation<AggregateRating>;
    /**
     * A single review of the app.
     */
    review?: NodeRelation<Review>;
    /**
     * The type of app (for example, BusinessApplication or GameApplication). The value must be a supported app type.
     */
    applicationCategory?: ApplicationCategory;
    /**
     * The operating system(s) required to use the app (for example, Windows 7, OSX 10.6, Android 1.6)
     */
    operatingSystem?: string;
}
interface SoftwareApp extends SoftwareAppSimple {
}

type Arrayable$1<T> = T | Array<T>;
type NodeRelation<T> = T | IdReference;
type NodeRelations<T> = Arrayable$1<NodeRelation<T>>;
type Identity = Person | Organization;
type ResolvableDate = string | Date;
type OptionalSchemaOrgPrefix<T extends string> = T | `https://schema.org/${T}`;
interface MetaInput {
    /**
     * Whether to inject the scripts at the end of the body or in the head.
     */
    tagPosition?: 'body' | 'head';
    trailingSlash?: boolean;
    host: string;
    url?: string;
    path?: string;
    currency?: string;
    image?: string;
    inLanguage?: string;
    title?: string;
    description?: string;
    datePublished?: Date | string;
    dateModified?: Date | string;
    /**
     * @deprecated use tagPosition
     */
    position?: 'body' | 'head';
    /**
     * @deprecated use `language`
     */
    defaultLanguage?: string;
    /**
     * @deprecated use `currency`
     */
    defaultCurrency?: string;
    /**
     * @deprecated use `host`
     */
    canonicalHost?: string;
    /**
     * @deprecated use `url` or `path`
     */
    canonicalUrl?: string;
    /**
     * @deprecated use root keys.
     */
    meta?: MetaInput;
}
interface UserConfig extends MetaInput {
}
interface Thing {
    '@type'?: Arrayable$1<string>;
    '@id'?: Id;
    /**
     * A reference-by-ID to the WebPage node.
     */
    mainEntityOfPage?: Arrayable$1<IdReference>;
    /**
     * A reference-by-ID to the WebPage node.
     */
    mainEntity?: Arrayable$1<IdReference>;
    /**
     * An image object or referenced by ID.
     * - Must be at least 696 pixels wide.
     * - Must be of the following formats+file extensions: .jpg, .png, .gif ,or .webp.
     */
    image?: NodeRelations<ImageObject | string>;
    /**
     * Allow any arbitrary keys
     */
    [key: string]: any;
}
interface IdReference {
    /** IRI identifying the canonical address of this object. */
    '@id': string;
}
type Id = `#${string}` | `https://${string}#${string}`;

declare function SchemaOrgUnheadPlugin(config: MetaInput, meta: () => Record<string, any>): any;

type DeepMaybeRef<T> = {
    [key in keyof T]?: MaybeComputedRefOrPromise<T[key]>;
};
declare function defineAddress<T extends Record<string, any>>(input?: DeepMaybeRef<PostalAddress & T>): DeepMaybeRef<PostalAddress & T>;
declare function defineAggregateOffer<T extends Record<string, any>>(input?: DeepMaybeRef<AggregateOffer & T>): DeepMaybeRef<AggregateOffer & T>;
declare function defineAggregateRating<T extends Record<string, any>>(input?: DeepMaybeRef<AggregateRating & T>): DeepMaybeRef<AggregateRating & T>;
declare function defineArticle<T extends Record<string, any>>(input?: DeepMaybeRef<Article & T>): DeepMaybeRef<Article & T>;
declare function defineBreadcrumb<T extends Record<string, any>>(input?: DeepMaybeRef<BreadcrumbList & T>): DeepMaybeRef<BreadcrumbList & T>;
declare function defineComment<T extends Record<string, any>>(input?: DeepMaybeRef<Comment$1 & T>): DeepMaybeRef<Comment$1 & T>;
declare function defineEvent<T extends Record<string, any>>(input?: DeepMaybeRef<Event & T>): DeepMaybeRef<Event & T>;
declare function defineVirtualLocation<T extends Record<string, any>>(input?: DeepMaybeRef<VirtualLocation & T>): DeepMaybeRef<VirtualLocation & T>;
declare function definePlace<T extends Record<string, any>>(input?: DeepMaybeRef<Place & T>): DeepMaybeRef<Place & T>;
declare function defineHowTo<T extends Record<string, any>>(input?: DeepMaybeRef<HowTo & T>): DeepMaybeRef<HowTo & T>;
declare function defineHowToStep<T extends Record<string, any>>(input?: DeepMaybeRef<HowToStep & T>): DeepMaybeRef<HowToStep & T>;
declare function defineImage<T extends Record<string, any>>(input?: DeepMaybeRef<ImageObject & T>): DeepMaybeRef<ImageObject & T>;
declare function defineJobPosting<T extends Record<string, any>>(input?: DeepMaybeRef<JobPosting & T>): DeepMaybeRef<JobPosting & T>;
declare function defineLocalBusiness<T extends Record<string, any>>(input?: DeepMaybeRef<LocalBusiness & T>): DeepMaybeRef<LocalBusiness & T>;
declare function defineOffer<T extends Record<string, any>>(input?: DeepMaybeRef<Offer & T>): DeepMaybeRef<Offer & T>;
declare function defineOpeningHours<T extends Record<string, any>>(input?: DeepMaybeRef<OpeningHoursSpecification & T>): DeepMaybeRef<OpeningHoursSpecification & T>;
declare function defineOrganization<T extends Record<string, any>>(input?: DeepMaybeRef<Organization & T>): DeepMaybeRef<Organization & T>;
declare function definePerson<T extends Record<string, any>>(input?: DeepMaybeRef<Person & T>): DeepMaybeRef<Person & T>;
declare function defineProduct<T extends Record<string, any>>(input?: DeepMaybeRef<Product & T>): DeepMaybeRef<Product & T>;
declare function defineQuestion<T extends Record<string, any>>(input?: DeepMaybeRef<Question & T>): DeepMaybeRef<Question & T>;
declare function defineRecipe<T extends Record<string, any>>(input?: DeepMaybeRef<Recipe & T>): DeepMaybeRef<Recipe & T>;
declare function defineReview<T extends Record<string, any>>(input?: DeepMaybeRef<Review & T>): DeepMaybeRef<Review & T>;
declare function defineVideo<T extends Record<string, any>>(input?: DeepMaybeRef<VideoObject & T>): DeepMaybeRef<VideoObject & T>;
declare function defineWebPage<T extends Record<string, any>>(input?: DeepMaybeRef<WebPage & T>): DeepMaybeRef<WebPage & T>;
declare function defineWebSite<T extends Record<string, any>>(input?: DeepMaybeRef<WebSite & T>): DeepMaybeRef<WebSite & T>;
declare function defineBook<T extends Record<string, any>>(input?: DeepMaybeRef<Book & T>): DeepMaybeRef<Book & T>;
declare function defineCourse<T extends Record<string, any>>(input?: DeepMaybeRef<Course & T>): DeepMaybeRef<Course & T>;
declare function defineItemList<T extends Record<string, any>>(input?: DeepMaybeRef<ItemList & T>): DeepMaybeRef<ItemList & T>;
declare function defineListItem<T extends Record<string, any>>(input?: DeepMaybeRef<ListItem & T>): DeepMaybeRef<ListItem & T>;
declare function defineMovie<T extends Record<string, any>>(input?: DeepMaybeRef<Movie & T>): DeepMaybeRef<Movie & T>;
declare function defineSearchAction<T extends Record<string, any>>(input?: DeepMaybeRef<SearchAction & T>): DeepMaybeRef<SearchAction & T>;
declare function defineReadAction<T extends Record<string, any>>(input?: DeepMaybeRef<ReadAction & T>): DeepMaybeRef<ReadAction & T>;
declare function defineSoftwareApp<T extends Record<string, any>>(input?: DeepMaybeRef<SoftwareApp & T>): DeepMaybeRef<SoftwareApp & T>;
declare function defineBookEdition<T extends Record<string, any>>(input?: DeepMaybeRef<BookEdition & T>): DeepMaybeRef<BookEdition & T>;
type Arrayable<T> = T | Array<T>;
declare function useSchemaOrg(input?: Arrayable<any>): any;

declare function defineSchemaOrgComponent(name: string, defineFn: (input: any) => any): vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgArticle: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgBreadcrumb: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgComment: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgEvent: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgHowTo: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgImage: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgJobPosting: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgLocalBusiness: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgOrganization: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgPerson: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgProduct: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgQuestion: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgRecipe: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgReview: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgVideo: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgWebPage: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgWebSite: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgMovie: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgCourse: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgItemList: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgBook: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;
declare const SchemaOrgSoftwareApp: vue.DefineComponent<{
    as: StringConstructor;
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}> | null, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    as: StringConstructor;
}>>, {}, {}>;

declare const SchemaOrgDebug: vue.DefineComponent<{
    console: {
        type: BooleanConstructor;
        default: boolean;
    };
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}>, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    console: {
        type: BooleanConstructor;
        default: boolean;
    };
}>>, {
    console: boolean;
}, {}>;

export { DeepMaybeRef, MetaInput, SchemaOrgArticle, SchemaOrgBook, SchemaOrgBreadcrumb, SchemaOrgComment, SchemaOrgCourse, SchemaOrgDebug, SchemaOrgEvent, SchemaOrgHowTo, SchemaOrgImage, SchemaOrgItemList, SchemaOrgJobPosting, SchemaOrgLocalBusiness, SchemaOrgMovie, SchemaOrgOrganization, SchemaOrgPerson, SchemaOrgProduct, SchemaOrgQuestion, SchemaOrgRecipe, SchemaOrgResolver, SchemaOrgResolverOptions, SchemaOrgReview, SchemaOrgSoftwareApp, SchemaOrgUnheadPlugin, SchemaOrgVideo, SchemaOrgWebPage, SchemaOrgWebSite, UserConfig, defineAddress, defineAggregateOffer, defineAggregateRating, defineArticle, defineBook, defineBookEdition, defineBreadcrumb, defineComment, defineCourse, defineEvent, defineHowTo, defineHowToStep, defineImage, defineItemList, defineJobPosting, defineListItem, defineLocalBusiness, defineMovie, defineOffer, defineOpeningHours, defineOrganization, definePerson, definePlace, defineProduct, defineQuestion, defineReadAction, defineRecipe, defineReview, defineSchemaOrgComponent, defineSearchAction, defineSoftwareApp, defineVideo, defineVirtualLocation, defineWebPage, defineWebSite, schemaAutoImports, schemaOrgAutoImports, schemaOrgComponents, useSchemaOrg };
