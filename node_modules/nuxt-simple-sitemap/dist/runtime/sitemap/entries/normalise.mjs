import { hasProtocol, joinURL } from "ufo";
import { defu } from "defu";
import { fixSlashes } from "site-config-stack";
import { createFilter } from "../../util/urlFilter.mjs";
import { mergeOnKey } from "../../util/pageUtils.mjs";
export async function normaliseSitemapData(data, options) {
  const {
    defaults,
    exclude,
    include,
    autoLastmod,
    autoAlternativeLangPrefixes
  } = options.moduleConfig;
  const combinedInclude = [...options.sitemap?.include || [], ...include || []];
  const combinedExclude = [...options.sitemap?.exclude || [], ...exclude || []];
  const urlFilter = createFilter({ include: combinedInclude, exclude: combinedExclude });
  function resolve(s) {
    if (!s)
      return;
    s = typeof s === "string" ? s : s.toString();
    if (hasProtocol(s, { acceptRelative: true, strict: false }))
      return s;
    return options.canonicalUrlResolver(s);
  }
  const defaultEntryData = defu(options.sitemap?.defaults, defaults);
  if (autoLastmod)
    defaultEntryData.lastmod = defaultEntryData.lastmod || /* @__PURE__ */ new Date();
  const entries = data.map((e) => typeof e === "string" ? { loc: e } : e).map((e) => {
    e = { ...e };
    if (e.url) {
      e.loc = e.url;
      delete e.url;
    }
    e.loc = fixSlashes(false, e.loc);
    e = defu(e, defaultEntryData);
    return e;
  }).map((e) => {
    const routeRules = options.getRouteRulesForPath(e.loc);
    if (routeRules.index === false)
      return false;
    return defu(routeRules.sitemap || {}, e);
  }).filter((e) => e && urlFilter(e.loc));
  if (Array.isArray(autoAlternativeLangPrefixes)) {
    entries.map((e) => {
      e.alternatives = e.alternatives || [
        { hreflang: "x-default", href: e.loc },
        ...autoAlternativeLangPrefixes.map((prefix) => ({
          hreflang: prefix,
          href: joinURL(prefix, e.loc)
        }))
      ];
      return e;
    });
  }
  function normaliseEntry(e) {
    if (e.lastmod) {
      const date = normaliseDate(e.lastmod);
      if (date)
        e.lastmod = date;
      else
        delete e.lastmod;
    }
    if (!e.lastmod)
      delete e.lastmod;
    e.loc = resolve(e.loc);
    if (e.alternatives) {
      e.alternatives = mergeOnKey(e.alternatives.map((e2) => {
        const a = { ...e2 };
        a.href = resolve(typeof a.href === "string" ? a.href : a.href.href);
        a.key = `${a.hreflang}:${a.href}`;
        return a;
      }), "key").map((e2) => {
        delete e2.key;
        return e2;
      });
    }
    if (e.images) {
      e.images = mergeOnKey(e.images.map((i) => {
        i = { ...i };
        i.loc = resolve(i.loc);
        return i;
      }), "loc");
    }
    if (e.videos) {
      e.videos = e.videos.map((v) => {
        v = { ...v };
        v.contentLoc = resolve(v.contentLoc);
        return v;
      });
    }
    return e;
  }
  function normaliseEntries(entries2) {
    return mergeOnKey(entries2.map(normaliseEntry), "loc").sort((a, b) => {
      if (a.loc > b.loc)
        return 1;
      if (a.loc < b.loc)
        return -1;
      return 0;
    }).sort((a, b) => {
      const aSegments = a.loc.split("/").length;
      const bSegments = b.loc.split("/").length;
      if (aSegments > bSegments)
        return 1;
      if (aSegments < bSegments)
        return -1;
      return 0;
    });
  }
  const ctx = { urls: normaliseEntries(entries), sitemapName: options.sitemap?.sitemapName || "sitemap" };
  if (options.callHook)
    await options.callHook(ctx);
  return normaliseEntries(ctx.urls);
}
export function normaliseDate(date) {
  const d = typeof date === "string" ? new Date(date) : date;
  if (!(d instanceof Date))
    return false;
  const z = (n) => `0${n}`.slice(-2);
  return `${d.getUTCFullYear()}-${z(d.getUTCMonth() + 1)}-${z(d.getUTCDate())}T${z(d.getUTCHours())}:${z(d.getUTCMinutes())}:${z(d.getUTCSeconds())}+00:00`;
}
